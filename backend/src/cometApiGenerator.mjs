// –ü–æ–ª–∏—Ñ–∏–ª–ª –¥–ª—è Buffer (—Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º–∏ –≤–µ—Ä—Å–∏—è–º–∏ Node.js)
console.log('üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ Buffer:', {
  globalThisBuffer: typeof globalThis.Buffer,
  globalBuffer: typeof global.Buffer,
  nodeVersion: process.version
});

// –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–æ–ª–∏—Ñ–∏–ª–ª –¥–ª—è Buffer
if (typeof globalThis.Buffer === 'undefined') {
  try {
    globalThis.Buffer = require('buffer').Buffer;
    console.log('‚úÖ Buffer –∑–∞–≥—Ä—É–∂–µ–Ω —á–µ—Ä–µ–∑ require("buffer")');
  } catch (e) {
    try {
      globalThis.Buffer = global.Buffer;
      console.log('‚úÖ Buffer –∑–∞–≥—Ä—É–∂–µ–Ω —á–µ—Ä–µ–∑ global.Buffer');
    } catch (e2) {
      // –ü–æ—Å–ª–µ–¥–Ω–∏–π fallback
      globalThis.Buffer = Buffer;
      console.log('‚úÖ Buffer –∑–∞–≥—Ä—É–∂–µ–Ω —á–µ—Ä–µ–∑ fallback');
    }
  }
}

import fetch from 'node-fetch';
import FormData from 'form-data';

// –ò–º–ø–æ—Ä—Ç Buffer —Å fallback
let Buffer;
try {
  Buffer = require('node:buffer').Buffer;
} catch (e) {
  try {
    Buffer = require('buffer').Buffer;
  } catch (e2) {
    Buffer = globalThis.Buffer || global.Buffer;
  }
}

// –§—É–Ω–∫—Ü–∏—è-–æ–±–µ—Ä—Ç–∫–∞ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è Buffer
function createBuffer(data, encoding = 'base64') {
  if (typeof Buffer === 'undefined') {
    throw new Error('Buffer –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–µ—Ä—Å–∏—é Node.js.');
  }
  return Buffer.from(data, encoding);
}

// –§—É–Ω–∫—Ü–∏—è-–æ–±–µ—Ä—Ç–∫–∞ –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –≤ base64
function toBase64(buffer) {
  if (typeof Buffer === 'undefined') {
    throw new Error('Buffer –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–µ—Ä—Å–∏—é Node.js.');
  }
  return buffer.toString('base64');
}
// –ë–∞–∑–æ–≤—ã–π URL –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π COMETAPI (–º–æ–∂–Ω–æ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —á–µ—Ä–µ–∑ env)
// –ú–æ–¥–µ–ª—å: gemini-2.5-flash-image (CometAPI, —Ñ–æ—Ä–º–∞—Ç generateContent) - —Å—Ç–∞–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è
const COMETAPI_IMAGE_URL = process.env.COMETAPI_IMAGE_URL || 'https://api.cometapi.com/v1beta/models/gemini-2.5-flash-image:generateContent';

import fs from 'fs';
import path from 'path';

// –ü—Ä–æ–º–ø—Ç—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ä–µ–∂–∏–º–æ–≤
const PROMPTS = {
  withoutFurniture: `ROLE
You are a professional architectural draftsman. When an input image is provided, you must redraw exactly what is there.

NON-NEGOTIABLES
NUMERICAL ABSOLUTE PROHIBITION (NAP): ABSOLUTELY FORBID ALL FORMS OF QUANTIFICATION. NEITHER NUMBERS, DIGITS, DECIMAL POINTS, NOR FRACTIONAL REPRESENTATIONS ARE PERMITTED.
Strictly same plan: do not change positions of walls, doors, windows, plumbing, or built-ins.
No invention: if something is ambiguous, keep a continuous wall; do not guess an opening.
ABSOLUTE TEXT BAN: produce graphics only. No digits (0-9), no decimal points (.), no fraction bars (/), no ratio colons (:), no letters, no symbols, no words, no abbreviations, no ‚Äúm¬≤‚Äù, no arrows, no degree signs, no punctuation, no legends, no stamps/watermarks, no logos, no title blocks, no dimension strings.

INPUT NORMALIZATION (PRESERVE GEOMETRY)
Rotate to 0¬∞/90¬∞/180¬∞/270¬∞.
Deskew + orthographic rectify (no foreshortening) while preserving all relative positions and proportions.
Remove paper edges, shadows, noise, background texture.
Erase all source text, numerical data, and quantification symbols (including index numbers, dimensions, and area labels). Do not trace any numbers (0-9), decimal points (.), or fractional indicators (/). Replace all numerical zones with a clean white, semantically inert background.

DRAWING SPEC ‚Äî WALLS & OPENINGS
All walls are solid black fills (mandatory):
Color #000000, no transparency/gray/patterns.
External load-bearing: 4‚Äì5 px total thickness.
Internal load-bearing: 3 px.
Partitions: 2 px.
Joints merge seamlessly; no hollow/outline-only walls.
Openings are white voids cut from black walls:
Doors: white gap + shortened leaf; add 1 px dashed swing arc inside the gap.
Windows: white opening with 2 px double frame; 45¬∞ glass hatching only inside the opening (walls remain solid black).
Zero bleed: black must not spill into openings or rooms.

FURNITURE & FIXTURES ‚Äî PRESERVE ONLY
Redraw only furniture/fixtures present in the source; do not add new items.
Use simple 2D icons; line weight 1 px.

VISUAL STYLE & OUTPUT
Background: pure white #FFFFFF.
Graphics: pure black #000000 only; no gray, color, gradients, textures, soft shading, or semi-transparency.
Canvas: 1200√ó1200 px, single final image (PNG or high-quality JPEG).

COMPOSITION
Plan centered; margins ‚â• 50 px.
No borders, title blocks, legends, scale bars, or north arrows.

HARD ‚ÄúNO-TEXT/NO-NUMBERS‚Äù ENFORCEMENT
Forbid any glyphs from any alphabet. Numerals (0-9), including their usage in decimals and fractions, are strictly forbidden. Explicitly exclude the decimal point (.), the fraction bar (/), the ratio colon (:), and the plus/minus symbol (¬±). Forbid punctuation, math signs, units (m, cm, m¬≤), degree (¬∞), hash (#), plus/minus (¬±), quotation marks, arrows (‚Üí ‚Üî ‚Üë ‚Üì), or OCR remnants.
If any text/number would appear, mask/paint it out to white instead.
Do not encode text as tiny strokes, dotted hints, hatch patterns, or decorative marks.

NEGATIVE PROMPTS
text, label, caption, font, lettering, handwriting, digits, numbers, area label, dimensions, 12.3 m¬≤, 1200, scale, north arrow, legend, watermark, logo, stamp, title block, revision table, tag, key.

EXECUTION ORDER
Normalize (rotate/deskew/rectify) without altering geometry.
Erase all text/numbers from the source ‚Üí replace with white.
Trace walls as solid black fills to spec; cut clean white openings; add door leaf + dashed arc, window double frame + 45¬∞ hatch (inside opening only).
Redraw only existing furniture/fixtures (1 px).
Final verification: layout identical; no text/numbers/symbols anywhere; black-on-white only.
Export 1200√ó1200.`,

  withFurniture: `You are a professional architectural draftsman. Redraw this 2D apartment floor plan into a high-quality technical drawing, preserving all proportions, layout, and room dimensions.

GLOBAL HARD CONSTRAINTS (must pass before output is accepted)

TILT/ANGLE RECTIFICATION ‚Äî MANDATORY:
If the attached photo/scan is tilted, rotated, skewed, or shot at an angle ‚Äî you MUST straighten it:

Rotate to 0¬∞/90¬∞/180¬∞/270¬∞ so all text is upright.

Deskew so walls are perfectly horizontal/vertical on an orthogonal grid.

Apply perspective rectification to produce a clean orthographic top-down plan (no foreshortening).

Do not proceed to drawing until rectification is complete. Target axis alignment tolerance ‚â§ 0.2¬∞.

WALLS MUST BE SOLID BLACK INSIDE (NO HOLLOW OUTLINES):
All wall bodies must be filled #000000 at 100% opacity with the specified stroke thickness. No white/gray cores, no hollow double-lines, no gradients, no hatching inside walls. Partitions are also solid black.

CANVAS FIT ‚Äî UNIFORM SCALE & MARGINS (STRICT)

CENTER the plan as a single unit.

UNIFORMLY SCALE (isotropic) to fill while keeping a HARD MINIMUM MARGIN ‚â• 50 px from any geometry/text to every edge.

Do NOT crop. Do NOT non-uniformly stretch. Maintain aspect ratio.

HARD RULE: No line, hatch, or text may touch or cross the image boundary.

STRUCTURAL ELEMENTS

External load-bearing walls: 4‚Äì5 px stroke, solid black fill (#000000, 100% opacity).

Internal load-bearing walls: 3 px stroke, solid black fill.

Partitions: 2 px stroke, solid black fill.

Doors: opening arc (1 px dashed) + shortened door leaf.

Windows: double frame 2 px + 45¬∞ diagonal glass hatching.

Balconies/loggias: determine only from explicit geometry (protrusions, glazing, railings).

VISUAL STYLE

Background: #FFFFFF.

Lines/fills: #000000 only.

No shadows, gradients, or gray tones.

Output: 1200√ó1200 px, JPG quality 95%.

ZERO-HALLUCINATION POLICY FOR FURNITURE/EQUIPMENT (HARD CONSTRAINT)

Default state: EMPTY ROOMS. Draw no furniture or equipment unless it is clearly, fully, and explicitly visible in the source image.

Never add or infer typical/default items. If any doubt exists, leave the room empty.

No completion from partial hints (fragments, stains, priors).

No auto-templates: do not place standard beds/sofas/tables/chairs/kitchens/wardrobes/TV/radiators/fixtures/etc.

If some furniture exists, draw only what is fully visible as simple geometric silhouettes with correct proportions.

Furniture line thickness: 1 px.

TEXT AND LABELS

Only room areas in the format ‚Äú12.3 m¬≤‚Äù.

Font: Arial, 12 px, black.

Place labels at room centers.

COMPOSITION

Plan centered.

Margins ‚â• 50 px on all sides.

No borders, titles, or dimension lines.

QUALITY GATES (execute in order; fail any ‚Üí fix and re-run)

Rectification check: walls axis-aligned (‚â§0.2¬∞), orthographic top-down achieved.

Wall fill check: every wall body is solid #000000 inside; no hollow/gray interiors.

Structure pass: walls/doors/windows drawn per specs.

Style pass: black/white only; no grays/gradients.

Margins pass: ‚â•50 px; nothing touches edges.

Furniture audit: rooms default empty; remove anything not explicitly visible.

Labels: only areas, correct format and placement.

NEGATIVE PROMPT (add separately if supported)

furniture, furnishings, bed, sofa, couch, sectional, armchair, table, desk, chair, stool, ottoman, wardrobe, closet, cabinet, shelf, shelving, kitchen, countertop, island, sink, cooktop, oven, fridge, hood, TV, TV stand, radiator, heater, AC, washing machine, dryer, bathtub, shower, toilet, bidet, vanity, mirror, lamp, chandelier, sconce, ceiling light, carpet, rug, plant, decor, curtain`
};

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —á–∏—Å—Ç—É—é –∫–æ–º–Ω–∞—Ç—É (—É–¥–∞–ª–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤) —Å –ø–æ–º–æ—â—å—é COMETAPI nano-banana-hd
 * @param {{imagePaths: string[]}} params
 * @returns {Promise<Buffer>} - –ë—É—Ñ–µ—Ä —Å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º
 */
export async function generateCleanupImage({ imagePaths = [] } = {}) {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å Buffer
  console.log('üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ Buffer –≤ generateCleanupImage:', {
    BufferType: typeof Buffer,
    BufferConstructor: typeof Buffer?.from,
    globalThisBuffer: typeof globalThis.Buffer,
    globalBuffer: typeof global.Buffer
  });
  
  if (typeof Buffer === 'undefined') {
    console.error('‚ùå Buffer –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω!');
    throw new Error('Buffer –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–µ—Ä—Å–∏—é Node.js.');
  }
  
  const apiKey = process.env.COMET_API_KEY;
  if (!apiKey) throw new Error('COMET_API_KEY –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è');
  if (!imagePaths || imagePaths.length === 0) throw new Error('–ù–µ –ø–µ—Ä–µ–¥–∞–Ω—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è');

  const prompt = `Transform the uploaded interior photo into the same room completely empty: keep only the original walls (with their real finishes/texture/pattern) and the existing floor. Remove everything else that is not a structural part of the room. Preserve geometry, perspective, lighting, and colors.

Remove completely (no traces left):

All furniture and loose items: sofas, armchairs, tables, chairs/stools, lamps, shelves, carpets/rugs, blankets, pillows, plants, boxes, tools, ladders, trash, cords.

All kitchen casework and contents: upper/lower cabinets, shelves, countertop, sink, faucet, cooktop/oven, small appliances, dishes, food, jars.

All decor and small objects: frames, books, vases, bowls, kettles, containers, textiles, etc.

All shadows/reflections/prints belonging to the removed objects.

Keep exactly as is (do not alter, move, or restyle):

Walls with their original finish: exposed brick, plaster, paint, wallpaper, tile/mosaic backsplash (including grout width, tile size, and tone).

Floor with its real pattern and direction (e.g., herringbone boards, tile joints, thresholds, transitions).

Architectural/structural elements only: doors/door frames, baseboards, window reveals, ceiling, built-in track lights/ceiling lights, sockets/switches, vents/grilles, fixed ducts/shafts, radiators, and wall/ceiling junctions.

Camera framing, focal length feel, horizon line, and vanishing lines.

Inpainting rules for occluded areas:

Extend the exact surface that should be behind the removed item.

If an object covered brick, continue the brick with the same brick size, mortar lines, chips, and weathering.

If it covered a mosaic backsplash, continue the grid with the same tile size, spacing, grout color, and subtle variations.

If it covered herringbone wood, continue the plank direction, plank width, and join pattern in correct perspective.

Respect perspective and scale (lines must converge consistently).

Match illumination: reconstruct soft ambient shading from the original light sources; do not introduce new lights or stylized highlights.

Quality constraints / do not do:

Do not add any new objects, decor, or fixtures from imagination.

Do not crop, rotate, upscale, or change aspect ratio; keep original resolution and framing.

Do not restyle or ‚Äúimprove‚Äù materials; keep a documentary, photorealistic look.

Avoid repeating textures, smudges, blur halos, or warped edges; seams and corners must stay sharp and straight.

Acceptance checklist (self-check before output):

No furniture, kitchen casework, appliances, decor, or clutter remains.

Wall finishes and floor pattern are continuous and believable at 100% zoom (no visible inpaint seams).

Doors, baseboards, track lights, outlets, vents, and other structural details are preserved and natural.

Lighting/color balance matches the original shot; no extra glare or ghosting.

Output:
Generate one photorealistic image of the same room, empty (bare walls + floor only), same size/aspect as the input.`;

  try {
    const outputs = [];
    for (const imagePath of imagePaths) {
      const imageBuffer = fs.readFileSync(imagePath);
      const base64 = imageBuffer.toString('base64');
      const ext = path.extname(imagePath).toLowerCase();
      const mime = ext === '.png' ? 'image/png' : 'image/jpeg';

      const requestBody = {
        contents: [
          {
            role: 'user',
            parts: [
              { text: prompt },
              { inline_data: { mime_type: mime, data: base64 } }
            ]
          }
        ],
        generationConfig: {
          responseModalities: ['IMAGE']
        }
      };

      const response = await retryWithBackoff(async () => {
        const resp = await fetch(COMETAPI_IMAGE_URL, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body: JSON.stringify(requestBody)
        });

        if (!resp.ok) {
          const errorText = await resp.text();
          throw new Error(`COMETAPI –æ—à–∏–±–∫–∞ ${resp.status} [${COMETAPI_IMAGE_URL}]: ${errorText}`);
        }
        
        return resp;
      });

      const result = await response.json();
      
      // –î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞ COMETAPI –¥–ª—è cleanup
      console.log('üîç –ü–æ–ª–Ω—ã–π –æ—Ç–≤–µ—Ç COMETAPI (cleanup):');
      console.log('üìä –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ—Ç–≤–µ—Ç–∞:', JSON.stringify(result, null, 2));
      console.log('üîç –ö–ª—é—á–∏ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è:', Object.keys(result));

      // –ò–∑–≤–ª–µ–∫–∞–µ–º base64 –∏–∑ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤
      let base64Image;
      if (result?.data?.image && typeof result.data.image === 'string') {
        base64Image = result.data.image;
      }
      if (!base64Image) {
        const candidates = result?.candidates || result?.contents || result?.responses;
        if (Array.isArray(candidates) && candidates.length > 0) {
          const first = candidates[0].content || candidates[0];
          const parts = first?.parts || first;
          if (Array.isArray(parts)) {
            const inlinePart = parts.find(p => 
              p?.inline_data?.data || p?.inline_data?.image || 
              p?.inlineData?.data || p?.inlineData?.image
            );
            if (inlinePart?.inline_data?.data) base64Image = inlinePart.inline_data.data;
            else if (inlinePart?.inline_data?.image) base64Image = inlinePart.inline_data.image;
            else if (inlinePart?.inlineData?.data) base64Image = inlinePart.inlineData.data;
            else if (inlinePart?.inlineData?.image) base64Image = inlinePart.inlineData.image;
          }
        }
      }
      if (!base64Image && Array.isArray(result?.media)) {
        const mediaItem = result.media.find(m => typeof m?.data === 'string');
        if (mediaItem?.data) base64Image = mediaItem.data;
      }
      if (!base64Image && typeof result?.image === 'string') base64Image = result.image;
      if (!base64Image && typeof result?.output === 'string') base64Image = result.output;
      if (!base64Image) {
        console.log('üîç –ì–ª—É–±–æ–∫–∏–π –ø–æ–∏—Å–∫ base64 –≤ cleanup...');
        const tryExtractBase64 = (obj, depth = 0) => {
          if (!obj || depth > 3) return null;
          if (typeof obj === 'string') {
            // —ç–≤—Ä–∏—Å—Ç–∏–∫–∞ base64-—Å—Ç—Ä–æ–∫–∏ - –ø—Ä–æ–≤–µ—Ä—è–µ–º –¥–ª–∏–Ω—É –∏ —Å–∏–º–≤–æ–ª—ã
            if (obj.length > 200 && /^[A-Za-z0-9+/=]+$/.test(obj)) {
              console.log(`‚úÖ –ù–∞–π–¥–µ–Ω–∞ base64 —Å—Ç—Ä–æ–∫–∞ –≤ cleanup (–¥–ª–∏–Ω–∞: ${obj.length})`);
              return obj;
            }
            return null;
          }
          if (Array.isArray(obj)) {
            for (const it of obj) {
              const found = tryExtractBase64(it, depth + 1);
              if (found) return found;
            }
            return null;
          }
          if (typeof obj === 'object') {
            const preferredKeys = ['image', 'data', 'inline_data', 'content', 'parts'];
            for (const k of preferredKeys) {
              if (obj[k]) {
                const found = tryExtractBase64(obj[k], depth + 1);
                if (found) return found;
              }
            }
            for (const k of Object.keys(obj)) {
              if (!preferredKeys.includes(k)) {
                const found = tryExtractBase64(obj[k], depth + 1);
                if (found) return found;
              }
            }
          }
          return null;
        };
        const guess = tryExtractBase64(result);
        if (guess) {
          console.log(`‚úÖ –ù–∞–π–¥–µ–Ω–∞ base64 —á–µ—Ä–µ–∑ –≥–ª—É–±–æ–∫–∏–π –ø–æ–∏—Å–∫ –≤ cleanup (–¥–ª–∏–Ω–∞: ${guess.length})`);
          base64Image = guess;
        }
      }

      if (!base64Image) {
        const preview = JSON.stringify(result).slice(0, 500);
        throw new Error('COMETAPI –Ω–µ –≤–µ—Ä–Ω—É–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ –æ–∂–∏–¥–∞–µ–º–æ–º —Ñ–æ—Ä–º–∞—Ç–µ: ' + preview);
      }

      const outBuffer = createBuffer(base64Image, 'base64');
      console.log('‚úÖ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ—á–∏—Å—Ç–∫–∏ —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ');
      console.log(`üìä –†–∞–∑–º–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ${outBuffer.length} –±–∞–π—Ç`);
      outputs.push(outBuffer);
    }

    return outputs;
  } catch (e) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—á–∏—Å—Ç–∫–∏ –∫–æ–º–Ω–∞—Ç—ã:', e);
    throw e;
  }
}

/**
 * Retry —Ñ—É–Ω–∫—Ü–∏—è —Å —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–π –∑–∞–¥–µ—Ä–∂–∫–æ–π
 * @param {Function} fn - –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
 * @param {number} maxRetries - –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫
 * @param {number} baseDelay - –ë–∞–∑–æ–≤–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –≤ –º—Å
 * @returns {Promise<any>}
 */
async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      const isLastAttempt = attempt === maxRetries - 1;
      
      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø—ã –æ—à–∏–±–æ–∫ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫
      const isServerError = error.message.includes('500') || 
                           error.message.includes('502') ||
                           error.message.includes('503') ||
                           error.message.includes('504') ||
                           error.message.includes('ÂΩìÂâçÂàÜÁªÑ‰∏äÊ∏∏Ë¥üËΩΩÂ∑≤È•±Âíå') ||
                           error.message.includes('shell_api_error') ||
                           error.message.includes('No available channels') ||
                           error.message.includes('comet_api_error');
      
      // –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–∫–∏ 503 (No available channels)
      if (error.message.includes('503') && error.message.includes('No available channels')) {
        console.error('üö´ COMETAPI: –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤ –¥–ª—è –º–æ–¥–µ–ª–∏. –°–µ—Ä–≤–∏—Å –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω.');
        throw new Error('–°–µ—Ä–≤–∏—Å –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
      }
      
      if (isLastAttempt || !isServerError) {
        // –õ–æ–≥–∏—Ä—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—É—é –æ—à–∏–±–∫—É —Å –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç—è–º–∏
        console.error(`‚ùå –§–∏–Ω–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –ø–æ—Å–ª–µ ${attempt + 1} –ø–æ–ø—ã—Ç–æ–∫:`, error.message);
        throw error;
      }
      
      const delay = baseDelay * Math.pow(2, attempt) + Math.random() * 1000;
      console.log(`‚è≥ –ü–æ–ø—ã—Ç–∫–∞ ${attempt + 1}/${maxRetries} –Ω–µ—É–¥–∞—á–Ω–∞ (${error.message.slice(0, 100)}...), –ø–æ–≤—Ç–æ—Ä —á–µ—Ä–µ–∑ ${Math.round(delay)}–º—Å...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –ø–ª–∞–Ω –∫–≤–∞—Ä—Ç–∏—Ä—ã —Å –ø–æ–º–æ—â—å—é COMETAPI nano-banana-hd
 * @param {string} imagePath - –ü—É—Ç—å –∫ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–º—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—é
 * @param {string} mode - –†–µ–∂–∏–º: 'withFurniture' –∏–ª–∏ 'withoutFurniture'
 * @returns {Promise<Buffer>} - –ë—É—Ñ–µ—Ä —Å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º
 */
export async function generateTechnicalPlan(imagePath, mode = 'withoutFurniture') {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å Buffer
  console.log('üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ Buffer –≤ generateTechnicalPlan:', {
    BufferType: typeof Buffer,
    BufferConstructor: typeof Buffer?.from,
    globalThisBuffer: typeof globalThis.Buffer,
    globalBuffer: typeof global.Buffer
  });
  
  if (typeof Buffer === 'undefined') {
    console.error('‚ùå Buffer –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω!');
    throw new Error('Buffer –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–µ—Ä—Å–∏—é Node.js.');
  }
  
  const apiKey = process.env.COMET_API_KEY;
  
  if (!apiKey) {
    throw new Error('COMET_API_KEY –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è');
  }

  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ API –∫–ª—é—á–∞
  if (apiKey === 'YOUR_COMET_API_KEY_HERE' || apiKey === 'YOUR_ACTUAL_COMET_API_KEY' || apiKey.length < 10) {
    console.error('‚ùå API –∫–ª—é—á –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω:', {
      keyLength: apiKey.length,
      keyStart: apiKey.substring(0, 10) + '...',
      isDefault: apiKey === 'YOUR_COMET_API_KEY_HERE' || apiKey === 'YOUR_ACTUAL_COMET_API_KEY'
    });
    throw new Error('COMET_API_KEY –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è –Ω–∞ —Ö–æ—Å—Ç–∏–Ω–≥–µ.');
  }

  if (!fs.existsSync(imagePath)) {
    throw new Error(`–§–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω: ${imagePath}`);
  }

  const prompt = PROMPTS[mode];
  if (!prompt) {
    throw new Error(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–∂–∏–º: ${mode}`);
  }

  try {
    console.log(`üé® –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–≥–æ –ø–ª–∞–Ω–∞ (—Ä–µ–∂–∏–º: ${mode})`);
    console.log(`üìÅ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: ${imagePath}`);
    
    const imageBuffer = fs.readFileSync(imagePath);
    const base64 = imageBuffer.toString('base64');
    const ext = path.extname(imagePath).toLowerCase();
    const mime = ext === '.png' ? 'image/png' : 'image/jpeg';

    const requestBody = {
      contents: [
        {
          role: 'user',
          parts: [
            { text: prompt },
            { inline_data: { mime_type: mime, data: base64 } }
          ]
        }
      ],
      generationConfig: {
        responseModalities: ['IMAGE']
      }
    };

    console.log('üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ COMETAPI (Nano-Banana)...');
    console.log(`üìù –ü—Ä–æ–º–ø—Ç –¥–ª–∏–Ω–∞: ${prompt.length} —Å–∏–º–≤–æ–ª–æ–≤`);
    console.log(`üñºÔ∏è –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: ${mime}, ${base64.length} —Å–∏–º–≤–æ–ª–æ–≤ base64`);
    console.log(`üîë API –∫–ª—é—á: ${apiKey.substring(0, 10)}...${apiKey.substring(apiKey.length - 5)}`);
    console.log(`üåê URL: ${COMETAPI_IMAGE_URL}`);

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º retry –ª–æ–≥–∏–∫—É –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ —Å–µ—Ä–≤–µ—Ä–∞
    const response = await retryWithBackoff(async () => {
      const headers = {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      };
      
      console.log('üìã –ó–∞–≥–æ–ª–æ–≤–∫–∏ –∑–∞–ø—Ä–æ—Å–∞:', headers);
      console.log('üì¶ –¢–µ–ª–æ –∑–∞–ø—Ä–æ—Å–∞ (–ø–µ—Ä–≤—ã–µ 500 —Å–∏–º–≤–æ–ª–æ–≤):', JSON.stringify(requestBody).substring(0, 500) + '...');
      
      const resp = await fetch(COMETAPI_IMAGE_URL, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(requestBody)
      });
      
      if (!resp.ok) {
        const errorText = await resp.text();
        throw new Error(`COMETAPI –æ—à–∏–±–∫–∞ ${resp.status} [${COMETAPI_IMAGE_URL}]: ${errorText?.slice(0, 500)}`);
      }
      
      return resp;
    });

    const result = await response.json();
    
    // –î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞ COMETAPI
    console.log('üîç –ü–æ–ª–Ω—ã–π –æ—Ç–≤–µ—Ç COMETAPI:');
    console.log('üìä –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ—Ç–≤–µ—Ç–∞:', JSON.stringify(result, null, 2));
    console.log('üîç –ö–ª—é—á–∏ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è:', Object.keys(result));
    
    if (result.candidates) {
      console.log('üìã –ö–∞–Ω–¥–∏–¥–∞—Ç—ã:', result.candidates.length);
      if (result.candidates[0]) {
        console.log('üìã –ü–µ—Ä–≤—ã–π –∫–∞–Ω–¥–∏–¥–∞—Ç:', Object.keys(result.candidates[0]));
        if (result.candidates[0].content) {
          console.log('üìã –ö–æ–Ω—Ç–µ–Ω—Ç:', Object.keys(result.candidates[0].content));
          if (result.candidates[0].content.parts) {
            console.log('üìã –ß–∞—Å—Ç–∏:', result.candidates[0].content.parts.length);
            result.candidates[0].content.parts.forEach((part, index) => {
              console.log(`üìã –ß–∞—Å—Ç—å ${index}:`, Object.keys(part));
              if (part.inline_data) {
                console.log(`üìã Inline data ${index}:`, Object.keys(part.inline_data));
                console.log(`üìã Data length ${index}:`, part.inline_data.data ? part.inline_data.data.length : '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö');
              }
            });
          }
        }
      }
    }

    let base64Image;

    // –í–∞—Ä–∏–∞–Ω—Ç 1: —Å—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç { data: { image: base64 } }
    if (result?.data?.image && typeof result.data.image === 'string') {
      base64Image = result.data.image;
    }

    // –í–∞—Ä–∏–∞–Ω—Ç 2: Gemini-–ø–æ–¥–æ–±–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç candidates -> content(parts[]) -> inline_data
    if (!base64Image) {
      const candidates = result?.candidates || result?.contents || result?.responses;
      if (Array.isArray(candidates) && candidates.length > 0) {
        const first = candidates[0].content || candidates[0];
        const parts = first?.parts || first;
        if (Array.isArray(parts)) {
          // –∏—â–µ–º —á–∞—Å—Ç—å —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º –æ–±–∞ —Ñ–æ—Ä–º–∞—Ç–∞: inline_data –∏ inlineData)
          const inlinePart = parts.find(p => 
            p?.inline_data?.data || p?.inline_data?.image || 
            p?.inlineData?.data || p?.inlineData?.image
          );
          if (inlinePart?.inline_data?.data) {
            base64Image = inlinePart.inline_data.data;
          } else if (inlinePart?.inline_data?.image) {
            base64Image = inlinePart.inline_data.image;
          } else if (inlinePart?.inlineData?.data) {
            base64Image = inlinePart.inlineData.data;
          } else if (inlinePart?.inlineData?.image) {
            base64Image = inlinePart.inlineData.image;
          }
        }
      }
    }

    // –í–∞—Ä–∏–∞–Ω—Ç 3: media –º–∞—Å—Å–∏–≤ —Å { mime_type, data }
    if (!base64Image && Array.isArray(result?.media)) {
      const mediaItem = result.media.find(m => typeof m?.data === 'string');
      if (mediaItem?.data) base64Image = mediaItem.data;
    }

    // –í–∞—Ä–∏–∞–Ω—Ç 4: –ø–ª–æ—Å–∫–∏–π –ø–æ–∏—Å–∫ –ø–æ –∏–∑–≤–µ—Å—Ç–Ω—ã–º –ø—É—Ç—è–º
    if (!base64Image && typeof result?.image === 'string') base64Image = result.image;
    if (!base64Image && typeof result?.output === 'string') base64Image = result.output;

    // –í–∞—Ä–∏–∞–Ω—Ç 5: –≥–ª—É–±–æ–∫–∏–π –ø–æ–∏—Å–∫ –ø–æ –æ–±—ä–µ–∫—Ç—É –ø–µ—Ä–≤—ã—Ö –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö 2-3 —É—Ä–æ–≤–Ω–µ–π
    if (!base64Image) {
      console.log('üîç –ì–ª—É–±–æ–∫–∏–π –ø–æ–∏—Å–∫ base64...');
      const tryExtractBase64 = (obj, depth = 0) => {
        if (!obj || depth > 3) return null;
        if (typeof obj === 'string') {
          // —ç–≤—Ä–∏—Å—Ç–∏–∫–∞ base64-—Å—Ç—Ä–æ–∫–∏ - –ø—Ä–æ–≤–µ—Ä—è–µ–º –¥–ª–∏–Ω—É –∏ —Å–∏–º–≤–æ–ª—ã
          if (obj.length > 200 && /^[A-Za-z0-9+/=]+$/.test(obj)) {
            console.log(`‚úÖ –ù–∞–π–¥–µ–Ω–∞ base64 —Å—Ç—Ä–æ–∫–∞ (–¥–ª–∏–Ω–∞: ${obj.length})`);
            return obj;
          }
          return null;
        }
        if (Array.isArray(obj)) {
          for (const it of obj) {
            const found = tryExtractBase64(it, depth + 1);
            if (found) return found;
          }
          return null;
        }
        if (typeof obj === 'object') {
          // –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ –∫–ª—é—á–∏
          const preferredKeys = ['image', 'data', 'inline_data', 'content', 'parts'];
          for (const k of preferredKeys) {
            if (obj[k]) {
              const found = tryExtractBase64(obj[k], depth + 1);
              if (found) return found;
            }
          }
          // –∏–Ω–∞—á–µ –ª—é–±–æ–π –∫–ª—é—á
          for (const k of Object.keys(obj)) {
            if (!preferredKeys.includes(k)) {
              const found = tryExtractBase64(obj[k], depth + 1);
              if (found) return found;
            }
          }
        }
        return null;
      };
      const guess = tryExtractBase64(result);
      if (guess) {
        console.log(`‚úÖ –ù–∞–π–¥–µ–Ω–∞ base64 —á–µ—Ä–µ–∑ –≥–ª—É–±–æ–∫–∏–π –ø–æ–∏—Å–∫ (–¥–ª–∏–Ω–∞: ${guess.length})`);
        base64Image = guess;
      }
    }

    if (!base64Image) {
      const preview = JSON.stringify(result).slice(0, 1000);
      console.error('‚ö†Ô∏è –û—Ç–≤–µ—Ç COMETAPI –±–µ–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –ø—Ä–µ–≤—å—é:', preview);
      throw new Error('COMETAPI –Ω–µ –≤–µ—Ä–Ω—É–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ –æ–∂–∏–¥–∞–µ–º–æ–º —Ñ–æ—Ä–º–∞—Ç–µ');
    }

    const outBuffer = createBuffer(base64Image, 'base64');
    console.log('‚úÖ –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –ø–ª–∞–Ω —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω');
    console.log(`üìä –†–∞–∑–º–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ${outBuffer.length} –±–∞–π—Ç`);
    
    return outBuffer;

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–≥–æ –ø–ª–∞–Ω–∞:', error);
    throw error;
  }
}


/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å COMETAPI
 * @returns {Promise<boolean>}
 */
export async function checkCometApiHealth() {
  const apiKey = process.env.COMET_API_KEY;
  
  if (!apiKey) {
    return false;
  }

  try {
    const response = await fetch('https://api.cometapi.com/v1/models', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      }
    });

    return response.ok;
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ COMETAPI:', error);
    return false;
  }
}

// –ü–æ–ª–∏—Ñ–∏–ª–ª –¥–ª—è Buffer (—Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º–∏ –≤–µ—Ä—Å–∏—è–º–∏ Node.js)
console.log('üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ Buffer:', {
  globalThisBuffer: typeof globalThis.Buffer,
  globalBuffer: typeof global.Buffer,
  nodeVersion: process.version
});

// –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–æ–ª–∏—Ñ–∏–ª–ª –¥–ª—è Buffer
if (typeof globalThis.Buffer === 'undefined') {
  try {
    globalThis.Buffer = require('buffer').Buffer;
    console.log('‚úÖ Buffer –∑–∞–≥—Ä—É–∂–µ–Ω —á–µ—Ä–µ–∑ require("buffer")');
  } catch (e) {
    try {
      globalThis.Buffer = global.Buffer;
      console.log('‚úÖ Buffer –∑–∞–≥—Ä—É–∂–µ–Ω —á–µ—Ä–µ–∑ global.Buffer');
    } catch (e2) {
      // –ü–æ—Å–ª–µ–¥–Ω–∏–π fallback
      globalThis.Buffer = Buffer;
      console.log('‚úÖ Buffer –∑–∞–≥—Ä—É–∂–µ–Ω —á–µ—Ä–µ–∑ fallback');
    }
  }
}

import fetch from 'node-fetch';
import FormData from 'form-data';

// –ò–º–ø–æ—Ä—Ç Buffer —Å fallback
let Buffer;
try {
  Buffer = require('node:buffer').Buffer;
} catch (e) {
  try {
    Buffer = require('buffer').Buffer;
  } catch (e2) {
    Buffer = globalThis.Buffer || global.Buffer;
  }
}

// –§—É–Ω–∫—Ü–∏—è-–æ–±–µ—Ä—Ç–∫–∞ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è Buffer
function createBuffer(data, encoding = 'base64') {
  if (typeof Buffer === 'undefined') {
    throw new Error('Buffer –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–µ—Ä—Å–∏—é Node.js.');
  }
  return Buffer.from(data, encoding);
}

// –§—É–Ω–∫—Ü–∏—è-–æ–±–µ—Ä—Ç–∫–∞ –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –≤ base64
function toBase64(buffer) {
  if (typeof Buffer === 'undefined') {
    throw new Error('Buffer –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–µ—Ä—Å–∏—é Node.js.');
  }
  return buffer.toString('base64');
}
// –ë–∞–∑–æ–≤—ã–π URL –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π COMETAPI (–º–æ–∂–Ω–æ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —á–µ—Ä–µ–∑ env)
// –ú–æ–¥–µ–ª—å: gemini-2.5-flash-image (CometAPI, —Ñ–æ—Ä–º–∞—Ç generateContent) - —Å—Ç–∞–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è
const COMETAPI_IMAGE_URL = process.env.COMETAPI_IMAGE_URL || 'https://api.cometapi.com/v1beta/models/gemini-2.5-flash-image:generateContent';

import fs from 'fs';
import path from 'path';

// –ü—Ä–æ–º–ø—Ç—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ä–µ–∂–∏–º–æ–≤
const PROMPTS = {
  withoutFurniture: `ROLE

You are a professional architectural draftsman. When an input image is provided, you must redraw exactly what is there.

NON-NEGOTIABLES

Strictly same plan: do not change positions of walls, doors, windows, plumbing, or built-ins.
No invention: if something is ambiguous, keep a continuous wall; do not guess an opening.

ABSOLUTE TEXT BAN: produce graphics only. No digits, no letters, no symbols, no words, no abbreviations, no "m¬≤", no arrows, no degree signs, no punctuation, no legends, no stamps/watermarks, no logos, no title blocks, no dimension strings.

INPUT NORMALIZATION (PRESERVE GEOMETRY)

Rotate to 0¬∞/90¬∞/180¬∞/270¬∞.
Deskew + orthographic rectify (no foreshortening) while preserving all relative positions and proportions.
Remove paper edges, shadows, noise, background texture.
Erase all source text: do not trace room names, areas, dimensions, labels, or numbers; replace them with clean white background.

DRAWING SPEC ‚Äî WALLS & OPENINGS

All walls are solid black fills (mandatory):
Color #000000, no transparency/gray/patterns.
External load-bearing: 4‚Äì5 px total thickness.
Internal load-bearing: 3 px.
Partitions: 2 px.
Joints merge seamlessly; no hollow/outline-only walls.

Openings are white voids cut from black walls:
Doors: white gap + shortened leaf; add 1 px dashed swing arc inside the gap.
Windows: white opening with 2 px double frame; 45¬∞ glass hatching only inside the opening (walls remain solid black).
Zero bleed: black must not spill into openings or rooms.

FURNITURE & FIXTURES ‚Äî PRESERVE ONLY

Redraw only furniture/fixtures present in the source; do not add new items.
Use simple 2D icons; line weight 1 px.

VISUAL STYLE & OUTPUT

Background: pure white #FFFFFF.
Graphics: pure black #000000 only; no gray, color, gradients, textures, soft shading, or semi-transparency.
Canvas: 1200√ó1200 px, single final image (PNG or high-quality JPEG).

COMPOSITION

Plan centered; margins ‚â• 50 px.
No borders, title blocks, legends, scale bars, or north arrows.

HARD "NO-TEXT/NO-NUMBERS" ENFORCEMENT

Forbid any glyphs from any alphabet, numerals (0-9), punctuation, math signs, units (m, cm, m¬≤), degree (¬∞), hash (#), plus/minus (¬±), quotation marks, arrows (‚Üí ‚Üî ‚Üë ‚Üì), or OCR remnants.
If any text/number would appear, mask/paint it out to white instead.
Do not encode text as tiny strokes, dotted hints, hatch patterns, or decorative marks.

NEGATIVE PROMPTS

text, label, caption, font, lettering, handwriting, digits, numbers, area label, dimensions, 12.3 m¬≤, 1200, scale, north arrow, legend, watermark, logo, stamp, title block, revision table, tag, key.

EXECUTION ORDER

Normalize (rotate/deskew/rectify) without altering geometry.
Erase all text/numbers from the source ‚Üí replace with white.
Trace walls as solid black fills to spec; cut clean white openings; add door leaf + dashed arc, window double frame + 45¬∞ hatch (inside opening only).
Redraw only existing furniture/fixtures (1 px).
Final verification: layout identical; no text/numbers/symbols anywhere; black-on-white only.
Export 1200√ó1200.`,

  withFurniture: `ROLE

You are a professional architectural draftsman. Lives depend on your accuracy.
MISSION ‚Äî TWO PHASES ONLY (MANDATORY ORDER)

PHASE A ‚Äî PLAN-ONLY REDRAW: Recreate exactly what is in the source: same walls, same openings, same plumbing/built-ins, same geometry and proportions. Do not add or remove anything.
PHASE B ‚Äî FURNITURE-ONLY ADDITION: After Phase A is complete and frozen, add minimal, logical furniture inside existing rooms without changing or touching the plan from Phase A.
HARD STRUCTURE LOCK (ABSOLUTE)

Room count must be identical to the source. No new rooms, corridors, balconies, niches, bay windows, alcoves, partitions, or shafts.
No new walls/partitions (not even thin lines), no moved walls, no thickening or trimming.
No new, moved, or resized openings (doors/windows). Door swings remain exactly where they are.
Exterior outline, interior topology, and opening locations must match pixel-for-pixel after deskew/rectification.
If furniture placement would conflict with the plan, remove the furniture instead of changing the plan.
INPUT NORMALIZATION

Rotate to 0¬∞/90¬∞/180¬∞/270¬∞, deskew, rectify to orthographic; preserve all relative positions and proportions.
Remove paper edges/shadows/noise. Erase any source text to white (do not trace labels).
STYLE & SPECS

Background #FFFFFF, graphics #000000 only (no gray/gradients/textures).
Walls: solid black fills; ext. 4‚Äì5 px, int. 3 px, partitions (if present in source) 2 px.
Doors: white gap + short leaf + 1 px dashed swing arc (inside the gap).
Windows: white gap + 2 px double frame + 45¬∞ hatch inside the opening only.
Furniture icons: simple 2D, 1 px line, black; must stay entirely inside rooms, never overlap walls, door gaps, or window voids; keep walkways clear; do not fuse with walls (except built-ins like kitchen base units flush inside the room).
Canvas: 1200√ó1200 px (PNG or high-quality JPEG). Plan centered; ‚â•50 px margins.
FURNITURE LOGIC (ONLY IF ROOM FUNCTION IS CLEAR)

Living: sofa, coffee table, media shelf.
Bedroom: bed (+ nightstands), wardrobe.
Kitchen/Kitchen-living: base cabinets, sink, cooktop, fridge; table + chairs if fits.
Bath/WC: toilet, sink, bath or shower (not both unless clearly fits).
Hall/Entry: wardrobe/shoe bench.
If function is unclear ‚Äî leave empty. Minimal set over guesswork.
ABSOLUTE TEXT BAN

No letters, digits, symbols, units, arrows, stamps, logos, titles, dimensions, labels ‚Äî nothing textual. If any appears, paint to white.
NEGATIVE PROMPTS

extra room, added corridor, balcony, niche, bay window, partition, moved wall, shifted door, resized window, new opening, text, label, dimension, scale bar, north arrow, legend, watermark, logo, stamp, title block.
EXECUTION CHECKS (REFUSAL RULE)

Lock structure: number of rooms, wall network, and openings must exactly match the source after rectification.
If any furniture would violate the lock (block doors/windows, cross walls, force a new layout), do not place that furniture.
Final image = Phase A unchanged + Phase B furniture inside rooms only, black-on-white, no text.`
};

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —á–∏—Å—Ç—É—é –∫–æ–º–Ω–∞—Ç—É (—É–¥–∞–ª–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤) —Å –ø–æ–º–æ—â—å—é COMETAPI nano-banana-hd
 * @param {{imagePaths: string[]}} params
 * @returns {Promise<Buffer>} - –ë—É—Ñ–µ—Ä —Å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º
 */
export async function generateCleanupImage({ imagePaths = [] } = {}) {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å Buffer
  console.log('üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ Buffer –≤ generateCleanupImage:', {
    BufferType: typeof Buffer,
    BufferConstructor: typeof Buffer?.from,
    globalThisBuffer: typeof globalThis.Buffer,
    globalBuffer: typeof global.Buffer
  });
  
  if (typeof Buffer === 'undefined') {
    console.error('‚ùå Buffer –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω!');
    throw new Error('Buffer –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–µ—Ä—Å–∏—é Node.js.');
  }
  
  const apiKey = process.env.COMET_API_KEY;
  if (!apiKey) throw new Error('COMET_API_KEY –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è');
  if (!imagePaths || imagePaths.length === 0) throw new Error('–ù–µ –ø–µ—Ä–µ–¥–∞–Ω—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è');

  const prompt = `Transform the uploaded interior photo into the same room completely empty: keep only the original walls (with their real finishes/texture/pattern) and the existing floor. Remove everything else that is not a structural part of the room. Preserve geometry, perspective, lighting, and colors.

Remove completely (no traces left):

All furniture and loose items: sofas, armchairs, tables, chairs/stools, lamps, shelves, carpets/rugs, blankets, pillows, plants, boxes, tools, ladders, trash, cords.

All kitchen casework and contents: upper/lower cabinets, shelves, countertop, sink, faucet, cooktop/oven, small appliances, dishes, food, jars.

All decor and small objects: frames, books, vases, bowls, kettles, containers, textiles, etc.

All shadows/reflections/prints belonging to the removed objects.

Keep exactly as is (do not alter, move, or restyle):

Walls with their original finish: exposed brick, plaster, paint, wallpaper, tile/mosaic backsplash (including grout width, tile size, and tone).

Floor with its real pattern and direction (e.g., herringbone boards, tile joints, thresholds, transitions).

Architectural/structural elements only: doors/door frames, baseboards, window reveals, ceiling, built-in track lights/ceiling lights, sockets/switches, vents/grilles, fixed ducts/shafts, radiators, and wall/ceiling junctions.

Camera framing, focal length feel, horizon line, and vanishing lines.

Inpainting rules for occluded areas:

Extend the exact surface that should be behind the removed item.

If an object covered brick, continue the brick with the same brick size, mortar lines, chips, and weathering.

If it covered a mosaic backsplash, continue the grid with the same tile size, spacing, grout color, and subtle variations.

If it covered herringbone wood, continue the plank direction, plank width, and join pattern in correct perspective.

Respect perspective and scale (lines must converge consistently).

Match illumination: reconstruct soft ambient shading from the original light sources; do not introduce new lights or stylized highlights.

Quality constraints / do not do:

Do not add any new objects, decor, or fixtures from imagination.

Do not crop, rotate, upscale, or change aspect ratio; keep original resolution and framing.

Do not restyle or ‚Äúimprove‚Äù materials; keep a documentary, photorealistic look.

Avoid repeating textures, smudges, blur halos, or warped edges; seams and corners must stay sharp and straight.

Acceptance checklist (self-check before output):

No furniture, kitchen casework, appliances, decor, or clutter remains.

Wall finishes and floor pattern are continuous and believable at 100% zoom (no visible inpaint seams).

Doors, baseboards, track lights, outlets, vents, and other structural details are preserved and natural.

Lighting/color balance matches the original shot; no extra glare or ghosting.

Output:
Generate one photorealistic image of the same room, empty (bare walls + floor only), same size/aspect as the input.`;

  try {
    const outputs = [];
    for (const imagePath of imagePaths) {
      const imageBuffer = fs.readFileSync(imagePath);
      const base64 = imageBuffer.toString('base64');
      const ext = path.extname(imagePath).toLowerCase();
      const mime = ext === '.png' ? 'image/png' : 'image/jpeg';

      const requestBody = {
        contents: [
          {
            role: 'user',
            parts: [
              { text: prompt },
              { inline_data: { mime_type: mime, data: base64 } }
            ]
          }
        ],
        generationConfig: {
          responseModalities: ['IMAGE']
        }
      };

      const response = await retryWithBackoff(async () => {
        const resp = await fetch(COMETAPI_IMAGE_URL, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body: JSON.stringify(requestBody)
        });

        if (!resp.ok) {
          const errorText = await resp.text();
          throw new Error(`COMETAPI –æ—à–∏–±–∫–∞ ${resp.status} [${COMETAPI_IMAGE_URL}]: ${errorText}`);
        }
        
        return resp;
      });

      const result = await response.json();
      
      // –î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞ COMETAPI –¥–ª—è cleanup
      console.log('üîç –ü–æ–ª–Ω—ã–π –æ—Ç–≤–µ—Ç COMETAPI (cleanup):');
      console.log('üìä –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ—Ç–≤–µ—Ç–∞:', JSON.stringify(result, null, 2));
      console.log('üîç –ö–ª—é—á–∏ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è:', Object.keys(result));

      // –ò–∑–≤–ª–µ–∫–∞–µ–º base64 –∏–∑ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤
      let base64Image;
      if (result?.data?.image && typeof result.data.image === 'string') {
        base64Image = result.data.image;
      }
      if (!base64Image) {
        const candidates = result?.candidates || result?.contents || result?.responses;
        if (Array.isArray(candidates) && candidates.length > 0) {
          const first = candidates[0].content || candidates[0];
          const parts = first?.parts || first;
          if (Array.isArray(parts)) {
            const inlinePart = parts.find(p => 
              p?.inline_data?.data || p?.inline_data?.image || 
              p?.inlineData?.data || p?.inlineData?.image
            );
            if (inlinePart?.inline_data?.data) base64Image = inlinePart.inline_data.data;
            else if (inlinePart?.inline_data?.image) base64Image = inlinePart.inline_data.image;
            else if (inlinePart?.inlineData?.data) base64Image = inlinePart.inlineData.data;
            else if (inlinePart?.inlineData?.image) base64Image = inlinePart.inlineData.image;
          }
        }
      }
      if (!base64Image && Array.isArray(result?.media)) {
        const mediaItem = result.media.find(m => typeof m?.data === 'string');
        if (mediaItem?.data) base64Image = mediaItem.data;
      }
      if (!base64Image && typeof result?.image === 'string') base64Image = result.image;
      if (!base64Image && typeof result?.output === 'string') base64Image = result.output;
      if (!base64Image) {
        console.log('üîç –ì–ª—É–±–æ–∫–∏–π –ø–æ–∏—Å–∫ base64 –≤ cleanup...');
        const tryExtractBase64 = (obj, depth = 0) => {
          if (!obj || depth > 3) return null;
          if (typeof obj === 'string') {
            // —ç–≤—Ä–∏—Å—Ç–∏–∫–∞ base64-—Å—Ç—Ä–æ–∫–∏ - –ø—Ä–æ–≤–µ—Ä—è–µ–º –¥–ª–∏–Ω—É –∏ —Å–∏–º–≤–æ–ª—ã
            if (obj.length > 200 && /^[A-Za-z0-9+/=]+$/.test(obj)) {
              console.log(`‚úÖ –ù–∞–π–¥–µ–Ω–∞ base64 —Å—Ç—Ä–æ–∫–∞ –≤ cleanup (–¥–ª–∏–Ω–∞: ${obj.length})`);
              return obj;
            }
            return null;
          }
          if (Array.isArray(obj)) {
            for (const it of obj) {
              const found = tryExtractBase64(it, depth + 1);
              if (found) return found;
            }
            return null;
          }
          if (typeof obj === 'object') {
            const preferredKeys = ['image', 'data', 'inline_data', 'content', 'parts'];
            for (const k of preferredKeys) {
              if (obj[k]) {
                const found = tryExtractBase64(obj[k], depth + 1);
                if (found) return found;
              }
            }
            for (const k of Object.keys(obj)) {
              if (!preferredKeys.includes(k)) {
                const found = tryExtractBase64(obj[k], depth + 1);
                if (found) return found;
              }
            }
          }
          return null;
        };
        const guess = tryExtractBase64(result);
        if (guess) {
          console.log(`‚úÖ –ù–∞–π–¥–µ–Ω–∞ base64 —á–µ—Ä–µ–∑ –≥–ª—É–±–æ–∫–∏–π –ø–æ–∏—Å–∫ –≤ cleanup (–¥–ª–∏–Ω–∞: ${guess.length})`);
          base64Image = guess;
        }
      }

      if (!base64Image) {
        const preview = JSON.stringify(result).slice(0, 500);
        throw new Error('COMETAPI –Ω–µ –≤–µ—Ä–Ω—É–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ –æ–∂–∏–¥–∞–µ–º–æ–º —Ñ–æ—Ä–º–∞—Ç–µ: ' + preview);
      }

      const outBuffer = createBuffer(base64Image, 'base64');
      console.log('‚úÖ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ—á–∏—Å—Ç–∫–∏ —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ');
      console.log(`üìä –†–∞–∑–º–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ${outBuffer.length} –±–∞–π—Ç`);
      outputs.push(outBuffer);
    }

    return outputs;
  } catch (e) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—á–∏—Å—Ç–∫–∏ –∫–æ–º–Ω–∞—Ç—ã:', e);
    throw e;
  }
}

/**
 * Retry —Ñ—É–Ω–∫—Ü–∏—è —Å —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–π –∑–∞–¥–µ—Ä–∂–∫–æ–π
 * @param {Function} fn - –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
 * @param {number} maxRetries - –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫
 * @param {number} baseDelay - –ë–∞–∑–æ–≤–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –≤ –º—Å
 * @returns {Promise<any>}
 */
async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      const isLastAttempt = attempt === maxRetries - 1;
      
      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø—ã –æ—à–∏–±–æ–∫ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫
      const isServerError = error.message.includes('500') || 
                           error.message.includes('502') ||
                           error.message.includes('503') ||
                           error.message.includes('504') ||
                           error.message.includes('ÂΩìÂâçÂàÜÁªÑ‰∏äÊ∏∏Ë¥üËΩΩÂ∑≤È•±Âíå') ||
                           error.message.includes('shell_api_error') ||
                           error.message.includes('No available channels') ||
                           error.message.includes('comet_api_error');
      
      // –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–∫–∏ 503 (No available channels)
      if (error.message.includes('503') && error.message.includes('No available channels')) {
        console.error('üö´ COMETAPI: –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤ –¥–ª—è –º–æ–¥–µ–ª–∏. –°–µ—Ä–≤–∏—Å –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω.');
        throw new Error('–°–µ—Ä–≤–∏—Å –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
      }
      
      if (isLastAttempt || !isServerError) {
        // –õ–æ–≥–∏—Ä—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—É—é –æ—à–∏–±–∫—É —Å –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç—è–º–∏
        console.error(`‚ùå –§–∏–Ω–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –ø–æ—Å–ª–µ ${attempt + 1} –ø–æ–ø—ã—Ç–æ–∫:`, error.message);
        throw error;
      }
      
      const delay = baseDelay * Math.pow(2, attempt) + Math.random() * 1000;
      console.log(`‚è≥ –ü–æ–ø—ã—Ç–∫–∞ ${attempt + 1}/${maxRetries} –Ω–µ—É–¥–∞—á–Ω–∞ (${error.message.slice(0, 100)}...), –ø–æ–≤—Ç–æ—Ä —á–µ—Ä–µ–∑ ${Math.round(delay)}–º—Å...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –ø–ª–∞–Ω –∫–≤–∞—Ä—Ç–∏—Ä—ã —Å –ø–æ–º–æ—â—å—é COMETAPI nano-banana-hd
 * @param {string} imagePath - –ü—É—Ç—å –∫ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–º—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—é
 * @param {string} mode - –†–µ–∂–∏–º: 'withFurniture' –∏–ª–∏ 'withoutFurniture'
 * @returns {Promise<Buffer>} - –ë—É—Ñ–µ—Ä —Å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º
 */
export async function generateTechnicalPlan(imagePath, mode = 'withoutFurniture') {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å Buffer
  console.log('üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ Buffer –≤ generateTechnicalPlan:', {
    BufferType: typeof Buffer,
    BufferConstructor: typeof Buffer?.from,
    globalThisBuffer: typeof globalThis.Buffer,
    globalBuffer: typeof global.Buffer
  });
  
  if (typeof Buffer === 'undefined') {
    console.error('‚ùå Buffer –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω!');
    throw new Error('Buffer –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–µ—Ä—Å–∏—é Node.js.');
  }
  
  const apiKey = process.env.COMET_API_KEY;
  
  if (!apiKey) {
    throw new Error('COMET_API_KEY –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è');
  }

  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ API –∫–ª—é—á–∞
  if (apiKey === 'YOUR_COMET_API_KEY_HERE' || apiKey === 'YOUR_ACTUAL_COMET_API_KEY' || apiKey.length < 10) {
    console.error('‚ùå API –∫–ª—é—á –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω:', {
      keyLength: apiKey.length,
      keyStart: apiKey.substring(0, 10) + '...',
      isDefault: apiKey === 'YOUR_COMET_API_KEY_HERE' || apiKey === 'YOUR_ACTUAL_COMET_API_KEY'
    });
    throw new Error('COMET_API_KEY –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è –Ω–∞ —Ö–æ—Å—Ç–∏–Ω–≥–µ.');
  }

  if (!fs.existsSync(imagePath)) {
    throw new Error(`–§–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω: ${imagePath}`);
  }

  const prompt = PROMPTS[mode];
  if (!prompt) {
    throw new Error(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–∂–∏–º: ${mode}`);
  }

  try {
    console.log(`üé® –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–≥–æ –ø–ª–∞–Ω–∞ (—Ä–µ–∂–∏–º: ${mode})`);
    console.log(`üìÅ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: ${imagePath}`);
    
    const imageBuffer = fs.readFileSync(imagePath);
    const base64 = imageBuffer.toString('base64');
    const ext = path.extname(imagePath).toLowerCase();
    const mime = ext === '.png' ? 'image/png' : 'image/jpeg';

    const requestBody = {
      contents: [
        {
          role: 'user',
          parts: [
            { text: prompt },
            { inline_data: { mime_type: mime, data: base64 } }
          ]
        }
      ],
      generationConfig: {
        responseModalities: ['IMAGE']
      }
    };

    console.log('üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ COMETAPI (Nano-Banana)...');
    console.log(`üìù –ü—Ä–æ–º–ø—Ç –¥–ª–∏–Ω–∞: ${prompt.length} —Å–∏–º–≤–æ–ª–æ–≤`);
    console.log(`üñºÔ∏è –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: ${mime}, ${base64.length} —Å–∏–º–≤–æ–ª–æ–≤ base64`);
    console.log(`üîë API –∫–ª—é—á: ${apiKey.substring(0, 10)}...${apiKey.substring(apiKey.length - 5)}`);
    console.log(`üåê URL: ${COMETAPI_IMAGE_URL}`);

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º retry –ª–æ–≥–∏–∫—É –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ —Å–µ—Ä–≤–µ—Ä–∞
    const response = await retryWithBackoff(async () => {
      const headers = {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      };
      
      console.log('üìã –ó–∞–≥–æ–ª–æ–≤–∫–∏ –∑–∞–ø—Ä–æ—Å–∞:', headers);
      console.log('üì¶ –¢–µ–ª–æ –∑–∞–ø—Ä–æ—Å–∞ (–ø–µ—Ä–≤—ã–µ 500 —Å–∏–º–≤–æ–ª–æ–≤):', JSON.stringify(requestBody).substring(0, 500) + '...');
      
      const resp = await fetch(COMETAPI_IMAGE_URL, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(requestBody)
      });
      
      if (!resp.ok) {
        const errorText = await resp.text();
        throw new Error(`COMETAPI –æ—à–∏–±–∫–∞ ${resp.status} [${COMETAPI_IMAGE_URL}]: ${errorText?.slice(0, 500)}`);
      }
      
      return resp;
    });

    const result = await response.json();
    
    // –î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞ COMETAPI
    console.log('üîç –ü–æ–ª–Ω—ã–π –æ—Ç–≤–µ—Ç COMETAPI:');
    console.log('üìä –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ—Ç–≤–µ—Ç–∞:', JSON.stringify(result, null, 2));
    console.log('üîç –ö–ª—é—á–∏ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è:', Object.keys(result));
    
    if (result.candidates) {
      console.log('üìã –ö–∞–Ω–¥–∏–¥–∞—Ç—ã:', result.candidates.length);
      if (result.candidates[0]) {
        console.log('üìã –ü–µ—Ä–≤—ã–π –∫–∞–Ω–¥–∏–¥–∞—Ç:', Object.keys(result.candidates[0]));
        if (result.candidates[0].content) {
          console.log('üìã –ö–æ–Ω—Ç–µ–Ω—Ç:', Object.keys(result.candidates[0].content));
          if (result.candidates[0].content.parts) {
            console.log('üìã –ß–∞—Å—Ç–∏:', result.candidates[0].content.parts.length);
            result.candidates[0].content.parts.forEach((part, index) => {
              console.log(`üìã –ß–∞—Å—Ç—å ${index}:`, Object.keys(part));
              if (part.inline_data) {
                console.log(`üìã Inline data ${index}:`, Object.keys(part.inline_data));
                console.log(`üìã Data length ${index}:`, part.inline_data.data ? part.inline_data.data.length : '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö');
              }
            });
          }
        }
      }
    }

    let base64Image;

    // –í–∞—Ä–∏–∞–Ω—Ç 1: —Å—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç { data: { image: base64 } }
    if (result?.data?.image && typeof result.data.image === 'string') {
      base64Image = result.data.image;
    }

    // –í–∞—Ä–∏–∞–Ω—Ç 2: Gemini-–ø–æ–¥–æ–±–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç candidates -> content(parts[]) -> inline_data
    if (!base64Image) {
      const candidates = result?.candidates || result?.contents || result?.responses;
      if (Array.isArray(candidates) && candidates.length > 0) {
        const first = candidates[0].content || candidates[0];
        const parts = first?.parts || first;
        if (Array.isArray(parts)) {
          // –∏—â–µ–º —á–∞—Å—Ç—å —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º –æ–±–∞ —Ñ–æ—Ä–º–∞—Ç–∞: inline_data –∏ inlineData)
          const inlinePart = parts.find(p => 
            p?.inline_data?.data || p?.inline_data?.image || 
            p?.inlineData?.data || p?.inlineData?.image
          );
          if (inlinePart?.inline_data?.data) {
            base64Image = inlinePart.inline_data.data;
          } else if (inlinePart?.inline_data?.image) {
            base64Image = inlinePart.inline_data.image;
          } else if (inlinePart?.inlineData?.data) {
            base64Image = inlinePart.inlineData.data;
          } else if (inlinePart?.inlineData?.image) {
            base64Image = inlinePart.inlineData.image;
          }
        }
      }
    }

    // –í–∞—Ä–∏–∞–Ω—Ç 3: media –º–∞—Å—Å–∏–≤ —Å { mime_type, data }
    if (!base64Image && Array.isArray(result?.media)) {
      const mediaItem = result.media.find(m => typeof m?.data === 'string');
      if (mediaItem?.data) base64Image = mediaItem.data;
    }

    // –í–∞—Ä–∏–∞–Ω—Ç 4: –ø–ª–æ—Å–∫–∏–π –ø–æ–∏—Å–∫ –ø–æ –∏–∑–≤–µ—Å—Ç–Ω—ã–º –ø—É—Ç—è–º
    if (!base64Image && typeof result?.image === 'string') base64Image = result.image;
    if (!base64Image && typeof result?.output === 'string') base64Image = result.output;

    // –í–∞—Ä–∏–∞–Ω—Ç 5: –≥–ª—É–±–æ–∫–∏–π –ø–æ–∏—Å–∫ –ø–æ –æ–±—ä–µ–∫—Ç—É –ø–µ—Ä–≤—ã—Ö –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö 2-3 —É—Ä–æ–≤–Ω–µ–π
    if (!base64Image) {
      console.log('üîç –ì–ª—É–±–æ–∫–∏–π –ø–æ–∏—Å–∫ base64...');
      const tryExtractBase64 = (obj, depth = 0) => {
        if (!obj || depth > 3) return null;
        if (typeof obj === 'string') {
          // —ç–≤—Ä–∏—Å—Ç–∏–∫–∞ base64-—Å—Ç—Ä–æ–∫–∏ - –ø—Ä–æ–≤–µ—Ä—è–µ–º –¥–ª–∏–Ω—É –∏ —Å–∏–º–≤–æ–ª—ã
          if (obj.length > 200 && /^[A-Za-z0-9+/=]+$/.test(obj)) {
            console.log(`‚úÖ –ù–∞–π–¥–µ–Ω–∞ base64 —Å—Ç—Ä–æ–∫–∞ (–¥–ª–∏–Ω–∞: ${obj.length})`);
            return obj;
          }
          return null;
        }
        if (Array.isArray(obj)) {
          for (const it of obj) {
            const found = tryExtractBase64(it, depth + 1);
            if (found) return found;
          }
          return null;
        }
        if (typeof obj === 'object') {
          // –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ –∫–ª—é—á–∏
          const preferredKeys = ['image', 'data', 'inline_data', 'content', 'parts'];
          for (const k of preferredKeys) {
            if (obj[k]) {
              const found = tryExtractBase64(obj[k], depth + 1);
              if (found) return found;
            }
          }
          // –∏–Ω–∞—á–µ –ª—é–±–æ–π –∫–ª—é—á
          for (const k of Object.keys(obj)) {
            if (!preferredKeys.includes(k)) {
              const found = tryExtractBase64(obj[k], depth + 1);
              if (found) return found;
            }
          }
        }
        return null;
      };
      const guess = tryExtractBase64(result);
      if (guess) {
        console.log(`‚úÖ –ù–∞–π–¥–µ–Ω–∞ base64 —á–µ—Ä–µ–∑ –≥–ª—É–±–æ–∫–∏–π –ø–æ–∏—Å–∫ (–¥–ª–∏–Ω–∞: ${guess.length})`);
        base64Image = guess;
      }
    }

    if (!base64Image) {
      const preview = JSON.stringify(result).slice(0, 1000);
      console.error('‚ö†Ô∏è –û—Ç–≤–µ—Ç COMETAPI –±–µ–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –ø—Ä–µ–≤—å—é:', preview);
      throw new Error('COMETAPI –Ω–µ –≤–µ—Ä–Ω—É–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ –æ–∂–∏–¥–∞–µ–º–æ–º —Ñ–æ—Ä–º–∞—Ç–µ');
    }

    const outBuffer = createBuffer(base64Image, 'base64');
    console.log('‚úÖ –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –ø–ª–∞–Ω —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω');
    console.log(`üìä –†–∞–∑–º–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ${outBuffer.length} –±–∞–π—Ç`);
    
    return outBuffer;

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–≥–æ –ø–ª–∞–Ω–∞:', error);
    throw error;
  }
}


/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å COMETAPI
 * @returns {Promise<boolean>}
 */
export async function checkCometApiHealth() {
  const apiKey = process.env.COMET_API_KEY;
  
  if (!apiKey) {
    return false;
  }

  try {
    const response = await fetch('https://api.cometapi.com/v1/models', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      }
    });

    return response.ok;
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ COMETAPI:', error);
    return false;
  }
}
